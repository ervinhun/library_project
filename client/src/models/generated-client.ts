//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AddSampleDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    addSampleDataOnce(): Promise<AuthorDto[]> {
        let url_ = this.baseUrl + "/AddSampleDataOnce";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSampleDataOnce(_response);
        });
    }

    protected processAddSampleDataOnce(response: Response): Promise<AuthorDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorDto[]>(null as any);
    }
}

export class LibraryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getBookById(bookId: string | undefined): Promise<BookDto> {
        let url_ = this.baseUrl + "/GetBookById?";
        if (bookId === null)
            throw new globalThis.Error("The parameter 'bookId' cannot be null.");
        else if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBookById(_response);
        });
    }

    protected processGetBookById(response: Response): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto>(null as any);
    }

    getAuthorById(authorId: string | undefined): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/GetAuthorById?";
        if (authorId === null)
            throw new globalThis.Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "authorId=" + encodeURIComponent("" + authorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthorById(_response);
        });
    }

    protected processGetAuthorById(response: Response): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    getGenreById(genreId: string | undefined): Promise<GenreDto> {
        let url_ = this.baseUrl + "/GetGenreById?";
        if (genreId === null)
            throw new globalThis.Error("The parameter 'genreId' cannot be null.");
        else if (genreId !== undefined)
            url_ += "genreId=" + encodeURIComponent("" + genreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGenreById(_response);
        });
    }

    protected processGetGenreById(response: Response): Promise<GenreDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenreDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenreDto>(null as any);
    }

    getAllBooks(): Promise<BookDto[]> {
        let url_ = this.baseUrl + "/GetAllBooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllBooks(_response);
        });
    }

    protected processGetAllBooks(response: Response): Promise<BookDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto[]>(null as any);
    }

    getAllAuthors(): Promise<AuthorDto[]> {
        let url_ = this.baseUrl + "/GetAllAuthors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAuthors(_response);
        });
    }

    protected processGetAllAuthors(response: Response): Promise<AuthorDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorDto[]>(null as any);
    }

    getAllGenres(): Promise<GenreDto[]> {
        let url_ = this.baseUrl + "/GetAllGenres";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllGenres(_response);
        });
    }

    protected processGetAllGenres(response: Response): Promise<GenreDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenreDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenreDto[]>(null as any);
    }

    getAllBooksByGenre(genreId: string | undefined): Promise<BookDto[]> {
        let url_ = this.baseUrl + "/GetAllBooksByGenre?";
        if (genreId === null)
            throw new globalThis.Error("The parameter 'genreId' cannot be null.");
        else if (genreId !== undefined)
            url_ += "genreId=" + encodeURIComponent("" + genreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllBooksByGenre(_response);
        });
    }

    protected processGetAllBooksByGenre(response: Response): Promise<BookDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto[]>(null as any);
    }

    getAllBooksByAuthor(authorId: string | undefined): Promise<BookDto[]> {
        let url_ = this.baseUrl + "/GetAllBooksByAuthor?";
        if (authorId === null)
            throw new globalThis.Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "authorId=" + encodeURIComponent("" + authorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllBooksByAuthor(_response);
        });
    }

    protected processGetAllBooksByAuthor(response: Response): Promise<BookDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto[]>(null as any);
    }

    getAllBooksByTitle(title: string | undefined): Promise<BookDto[]> {
        let url_ = this.baseUrl + "/GetAllBooksByTitle?";
        if (title === null)
            throw new globalThis.Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllBooksByTitle(_response);
        });
    }

    protected processGetAllBooksByTitle(response: Response): Promise<BookDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto[]>(null as any);
    }

    addBook(books: BookDto[] | undefined, id: string | undefined, title: string | undefined, pages: number | undefined, createdat: string | null | undefined, genreid: string | null | undefined, genre_Id: string | undefined, genre_Name: string | undefined, genre_Createdat: string | null | undefined, authors: AuthorDto[] | undefined): Promise<BookDto> {
        let url_ = this.baseUrl + "/AddBook?";
        if (books === null)
            throw new globalThis.Error("The parameter 'books' cannot be null.");
        else if (books !== undefined)
            books && books.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Books[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (title === null)
            throw new globalThis.Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (pages === null)
            throw new globalThis.Error("The parameter 'pages' cannot be null.");
        else if (pages !== undefined)
            url_ += "Pages=" + encodeURIComponent("" + pages) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        if (genreid !== undefined && genreid !== null)
            url_ += "Genreid=" + encodeURIComponent("" + genreid) + "&";
        if (genre_Id === null)
            throw new globalThis.Error("The parameter 'genre_Id' cannot be null.");
        else if (genre_Id !== undefined)
            url_ += "Genre.Id=" + encodeURIComponent("" + genre_Id) + "&";
        if (genre_Name === null)
            throw new globalThis.Error("The parameter 'genre_Name' cannot be null.");
        else if (genre_Name !== undefined)
            url_ += "Genre.Name=" + encodeURIComponent("" + genre_Name) + "&";
        if (genre_Createdat !== undefined && genre_Createdat !== null)
            url_ += "Genre.Createdat=" + encodeURIComponent("" + genre_Createdat) + "&";
        if (authors === null)
            throw new globalThis.Error("The parameter 'authors' cannot be null.");
        else if (authors !== undefined)
            authors && authors.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Authors[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddBook(_response);
        });
    }

    protected processAddBook(response: Response): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto>(null as any);
    }

    addAuthor(id: string | undefined, name: string | undefined, createdat: string | null | undefined): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/AddAuthor?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAuthor(_response);
        });
    }

    protected processAddAuthor(response: Response): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    addGenre(id: string | undefined, name: string | undefined, createdat: string | null | undefined): Promise<GenreDto> {
        let url_ = this.baseUrl + "/AddGenre?";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddGenre(_response);
        });
    }

    protected processAddGenre(response: Response): Promise<GenreDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenreDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenreDto>(null as any);
    }

    updateBook(bookId: string | undefined, books: BookDto[] | undefined, id: string | undefined, title: string | undefined, pages: number | undefined, createdat: string | null | undefined, genreid: string | null | undefined, genre_Id: string | undefined, genre_Name: string | undefined, genre_Createdat: string | null | undefined, authors: AuthorDto[] | undefined): Promise<BookDto> {
        let url_ = this.baseUrl + "/UpdateBook?";
        if (bookId === null)
            throw new globalThis.Error("The parameter 'bookId' cannot be null.");
        else if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        if (books === null)
            throw new globalThis.Error("The parameter 'books' cannot be null.");
        else if (books !== undefined)
            books && books.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Books[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (title === null)
            throw new globalThis.Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (pages === null)
            throw new globalThis.Error("The parameter 'pages' cannot be null.");
        else if (pages !== undefined)
            url_ += "Pages=" + encodeURIComponent("" + pages) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        if (genreid !== undefined && genreid !== null)
            url_ += "Genreid=" + encodeURIComponent("" + genreid) + "&";
        if (genre_Id === null)
            throw new globalThis.Error("The parameter 'genre_Id' cannot be null.");
        else if (genre_Id !== undefined)
            url_ += "Genre.Id=" + encodeURIComponent("" + genre_Id) + "&";
        if (genre_Name === null)
            throw new globalThis.Error("The parameter 'genre_Name' cannot be null.");
        else if (genre_Name !== undefined)
            url_ += "Genre.Name=" + encodeURIComponent("" + genre_Name) + "&";
        if (genre_Createdat !== undefined && genre_Createdat !== null)
            url_ += "Genre.Createdat=" + encodeURIComponent("" + genre_Createdat) + "&";
        if (authors === null)
            throw new globalThis.Error("The parameter 'authors' cannot be null.");
        else if (authors !== undefined)
            authors && authors.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Authors[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBook(_response);
        });
    }

    protected processUpdateBook(response: Response): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BookDto>(null as any);
    }

    updateAuthor(authorId: string | undefined, id: string | undefined, name: string | undefined, createdat: string | null | undefined): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/UpdateAuthor?";
        if (authorId === null)
            throw new globalThis.Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "authorId=" + encodeURIComponent("" + authorId) + "&";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAuthor(_response);
        });
    }

    protected processUpdateAuthor(response: Response): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    updateGenre(genreId: string | undefined, id: string | undefined, name: string | undefined, createdat: string | null | undefined): Promise<GenreDto> {
        let url_ = this.baseUrl + "/UpdateGenre?";
        if (genreId === null)
            throw new globalThis.Error("The parameter 'genreId' cannot be null.");
        else if (genreId !== undefined)
            url_ += "genreId=" + encodeURIComponent("" + genreId) + "&";
        if (id === null)
            throw new globalThis.Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name === null)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (createdat !== undefined && createdat !== null)
            url_ += "Createdat=" + encodeURIComponent("" + createdat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateGenre(_response);
        });
    }

    protected processUpdateGenre(response: Response): Promise<GenreDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenreDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GenreDto>(null as any);
    }

    deleteBook(bookId: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/DeleteBook?";
        if (bookId === null)
            throw new globalThis.Error("The parameter 'bookId' cannot be null.");
        else if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBook(_response);
        });
    }

    protected processDeleteBook(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteAuthor(authorId: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/DeleteAuthor?";
        if (authorId === null)
            throw new globalThis.Error("The parameter 'authorId' cannot be null.");
        else if (authorId !== undefined)
            url_ += "authorId=" + encodeURIComponent("" + authorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAuthor(_response);
        });
    }

    protected processDeleteAuthor(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteGenre(genreId: string | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/DeleteGenre?";
        if (genreId === null)
            throw new globalThis.Error("The parameter 'genreId' cannot be null.");
        else if (genreId !== undefined)
            url_ += "genreId=" + encodeURIComponent("" + genreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGenre(_response);
        });
    }

    protected processDeleteGenre(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface AuthorDto {
    id?: string;
    name?: string;
    createdat?: string | undefined;
}

export interface BookDto {
    books?: BookDto[];
    id?: string;
    title?: string;
    pages?: number;
    createdat?: string | undefined;
    genreid?: string | undefined;
    genre?: GenreDto | undefined;
    authors?: AuthorDto[];
}

export interface GenreDto {
    id?: string;
    name?: string;
    createdat?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}